{% include navigation.html %}

- Database contains multiple tables for Student info and notes
``` java
@ManyToOne
    @JoinColumn(name="student_id")
    private Student student;
  ```
    
- Annotations used to achieve Many-to-One relation: each Student POJO has multiple corresponding Note POJOs

``` java 
@NonNull
    @Size(min = 1, message = "Name")
    private String name;

    private int table_number;


    private int period;

    /* Initializer used when setting data from an API */
    public Student(String name, int table_number, int period_number) {
        this.table_number = table_number;
        this.name = name;
        this.period = period_number;
    }
```
- Student POJO contains name, table number, and period. The constructor is used when saving entries to the database

``` java
Student student = modelRepository.get(id);
        List<Note> notes = noteRepository.findAllByStudent(student);
        Note note = new Note();
        note.setStudent(student);

        for (Note n : notes)
            n.setText(n.getText());
            
            @PostMapping("/database/notes")
    public String notesAdd(@Valid Note note, BindingResult bindingResult) {
        // back to person ID on redirect
        String redirect = "redirect:/database/notes/"+note.getStudent().getId();

        // database errors
        if (bindingResult.hasErrors()) {
            return redirect;
        }

        // note is saved and person ID is pre-set
        noteRepository.save(note);
 ```
 - Notes controller finds the student matching the id and then uses the findAllByStudent method with a Student object as a parameter to output a list of Notes object
 corresponding to that Student
 - For loop iterates through each of these notes and set's the text variable
 - Post-Mapping: HTML form submits a Notes object, which is combined with JPA repository save method to add to the database

``` java
public  List<Student>listAll() {
        return jpa.findAll();
    }


    public  List<Student>listLikeNative(String term) {
        String like_term = String.format("%%%s%%",term);  // Like required % rappers
        return jpa.findByLikeTermNative(like_term);
    }

    public void save(Student student) {
        jpa.save(student);

    }

    public Student get(long id) {
        return (jpa.findById(id).isPresent())
                ? jpa.findById(id).get()
                : null;
    }

    public void delete(long id) {
        jpa.deleteById(id);
    }
```
- Different CRUD methods used to add, update, and delete entries from the database

``` html
<tbody>
                    <tr th:each="student : ${list}">
                        <td th:text="${student.id}"> ID</td>
                        <td th:text="${student.name}"> Name</td>
                        <td th:text="${student.table_number}">Table</td>
                        <td th:text="${student.period}">Period</td>

                        <td>
                            <a th:href="@{/database/student_update/{id}(id = ${student.id})}">Update</a>
                            <a th:href="@{/database/student_delete/{id}(id = ${student.id})}">Delete</a>
                            <a th:href="@{/database/notes/{id}(id = ${student.id})}">Notes</a>
                        </td>
                    </tr>

                    </tbody>
```
- Thymeleaf table is generated by using th:each to iterate through the list of Student objects returned through the controller, each row prints a different variable from the Student POJO
- Links to the right redirect to pages for updating and deleting student, as well as adding Notes, using the student id as part of the url
