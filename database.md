{% include navigation.html %}

# Database
- Database contains multiple tables for Student info and notes
``` java
@ManyToOne
    @JoinColumn(name="student_id")
    private Student student;
  ```
    
- Annotations used to achieve Many-to-One relation: each Student POJO has multiple corresponding Note POJOs

``` java 
@NonNull
    @Size(min = 1, message = "Name")
    private String name;

    private int table_number;


    private int period;

    /* Initializer used when setting data from an API */
    public Student(String name, int table_number, int period_number) {
        this.table_number = table_number;
        this.name = name;
        this.period = period_number;
    }
```
- Student POJO contains name, table number, and period. The constructor is used when saving entries to the database

``` java
Student student = modelRepository.get(id);
        List<Note> notes = noteRepository.findAllByStudent(student);
        Note note = new Note();
        note.setStudent(student);

        for (Note n : notes)
            n.setText(n.getText());
            
            @PostMapping("/database/notes")
    public String notesAdd(@Valid Note note, BindingResult bindingResult) {
        // back to person ID on redirect
        String redirect = "redirect:/database/notes/"+note.getStudent().getId();

        // database errors
        if (bindingResult.hasErrors()) {
            return redirect;
        }

        // note is saved and person ID is pre-set
        noteRepository.save(note);
 ```
 - Notes controller finds the student matching the id and then uses the findAllByStudent method with a Student object as a parameter to output a list of Notes object
 corresponding to that Student
 - For loop iterates through each of these notes and set's the text variable
 - Post-Mapping: HTML form submits a Notes object, which is combined with JPA repository save method to add to the database

``` java
public  List<Student>listAll() {
        return jpa.findAll();
    }


    public  List<Student>listLikeNative(String term) {
        String like_term = String.format("%%%s%%",term);  // Like required % rappers
        return jpa.findByLikeTermNative(like_term);
    }

    public void save(Student student) {
        jpa.save(student);

    }

    public Student get(long id) {
        return (jpa.findById(id).isPresent())
                ? jpa.findById(id).get()
                : null;
    }

    public void delete(long id) {
        jpa.deleteById(id);
    }
```
- Different CRUD methods used to add, update, and delete entries from the database

``` html
<tbody>
                    <tr th:each="student : ${list}">
                        <td th:text="${student.id}"> ID</td>
                        <td th:text="${student.name}"> Name</td>
                        <td th:text="${student.table_number}">Table</td>
                        <td th:text="${student.period}">Period</td>

                        <td>
                            <a th:href="@{/database/student_update/{id}(id = ${student.id})}">Update</a>
                            <a th:href="@{/database/student_delete/{id}(id = ${student.id})}">Delete</a>
                            <a th:href="@{/database/notes/{id}(id = ${student.id})}">Notes</a>
                        </td>
                    </tr>

                    </tbody>
```
- Thymeleaf table is generated by using th:each to iterate through the list of Student objects returned through the controller, each row prints a different variable from the Student POJO
- Links to the right redirect to pages for updating and deleting student, as well as adding Notes, using the student id as part of the url


# Randomization Algorithm
sets studentsPerTable = numStudents/numTables, and then randomly adds students to table groups by creating Student objects with their table # and a random student name from the names list. Removes names from names list so that students can not be added to multiple groups.

```java
        studentsPerTable = numStudents / numTables;

        for (int i = 0; i < numTables; i++) {
            for (int j = 0; j < studentsPerTable; j++) {
                int index = (int) (Math.random() * names.size());
                StudentObject oneStudent = new StudentObject(i, names.get(index));
                groups.add(oneStudent);
                names.remove(index);
            }
        }
```
To deal with the case that numStudents is not divisble by numTables, we check that names is not empty (or names.size() > 0), and add the remaining students randomly to table 0 -> table n.
```java
        int i = 0;
            while(names.size() > 0 && i < numTables){
                int index = (int) (Math.random() * names.size());
                StudentObject oneStudent = new StudentObject(i, names.get(index));
                groups.add(oneStudent);
                names.remove(index);
                i++;
            }

        return groups;
```
After doing this, though, the students may not ordered by their table group. Thus, I implemented a selection sort in order to ensure that students within the same table are next to oneanother inside the arraylist.
```java
public static void sort(ArrayList<StudentObject> a){
        int n = a.size();

        for(int i =0;i < n-1; i++){
            int min_idx = i;
            for(int j = i+1; j < n; j++){
                if(a.get(j).getTableGroup() < a.get(min_idx).getTableGroup()){
                    min_idx = j;
                }
            }
            StudentObject temp = a.get(min_idx);
            a.set(min_idx, a.get(i));
            a.set(i, temp);
        }
    }
```
